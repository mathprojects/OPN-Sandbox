var
  n: BigInteger;
  qpower: BigInteger;
  ppower: BigInteger;
  ps_array: array of uint64;
  es_array: array of uint64;
  ps_index: array of Integer;
  es_index: array of Integer;
  q_index: Integer;
  alpha_index: Integer;
  q: uint64;
  alpha: uint64;
  i: Integer;
  s: string;

  function GreaterThanPower(x: BigInteger): uint64;
  var
    k: uint64;
    c: BigInteger;
  begin
    for k := 0 to 1000000 do
    begin
      if x < BigInteger.Pow(10,k) then
      begin
        result := k-1;
        exit;
      end;

    end;

  end;

  function SmallerThanPower(x: BigInteger): uint64;
  begin
    result := GreaterThanPower(x);
    result := result + 1;
  end;

  procedure CheckNumber;
  var
    indpower: BigInteger;
    largestindpower: BigInteger;
    smallestindpower: BigInteger;
    largestindindex: integer;
    smallestindindex: integer;
    j: Integer;
    sigma: BigInteger;
    divq, divr: BigInteger;
  begin
    q := StrToInt64(stringgrid1.Cells[0,q_index]);
    alpha := StrToInt64(stringgrid1.Cells[1,alpha_index]);
    for j := 0 to numps-1 do
    begin
      ps_array[j] := StrToInt64(stringgrid1.Cells[j*2+2,ps_index[j]]);
      es_array[j] := StrToInt64(stringgrid1.Cells[j*2+3,es_index[j]]);
    end;

    s := '(' + inttostr(q)+'^'+inttostr(alpha)+')';
    for j := 0 to numps-1 do
      s := s + '(' + inttostr(ps_array[j]) + '^' + inttostr(2*es_array[j]) + ')';

    Memo6.lines.add(s);

    qpower := BigInteger.Pow(q,alpha);
    memo6.Lines.Add('q^alpha is greater than 10^' + IntToStr(GreaterThanPower(qpower)));

    ppower := BigInteger.Pow(ps_array[0],es_array[0]);
    smallestindpower := ppower;
    largestindpower := ppower;
    smallestindindex := 0;
    largestindindex := 0;

    if numps > 1 then
    for j := 1 to numps-1 do
    begin
      indpower := BigInteger.Pow(ps_array[j],2*es_array[j]);
      if indpower < smallestindpower then
      begin
        smallestindpower := indpower;
        smallestindindex := j;
      end;
      if indpower > largestindpower then
      begin
        largestindpower := indpower;
        largestindindex := j;
      end;

      ppower := BigInteger.Multiply(ppower,indpower);
    end;

    memo6.Lines.Add('The smallest p power is p' +inttostr(smallestindindex+1) + '^2e' + inttostr(smallestindindex+1));
    memo6.Lines.Add('     it is smaller than 10^' + IntToStr(SmallerThanPower(smallestindpower)));
    memo6.Lines.Add('The largest p power is p' +inttostr(largestindindex+1) + '^2e' + inttostr(largestindindex+1));
    memo6.Lines.Add('     it is larger than 10^' + IntToStr(GreaterThanPower(largestindpower)));

    if BigInteger.Remainder(ppower-1,8)=0 then
      memo6.Lines.Add('P^2 is ≡ 1 mod 8')
    else
      memo6.Lines.Add('P^2 is NOT ≡ 1 mod 8');

   n := BigInteger.Multiply(qpower,ppower);

   memo6.Lines.Add('N is greater than 10^' + inttostr(GreaterThanPower(n)));

   if BigInteger.Remainder(n,105)=0 then
      memo6.Lines.Add('105 divides N')
    else
      memo6.Lines.Add('105 does NOT divide N');

   if (BigInteger.Remainder(n,3)=0)
      and (BigInteger.Remainder(n,5)=0)
      and (BigInteger.Remainder(n,7)=0) then
     memo6.Lines.Add('All of 3,5,7 divide N');

   if BigInteger.Remainder(n,3)=0 then
      memo6.Lines.Add('3 divides N')
    else
      memo6.Lines.Add('3 does NOT divide N');

   if BigInteger.Remainder(n-1,12)=0 then
      memo6.Lines.Add('N is ≡ 1 mod 12')
    else
      memo6.Lines.Add('N is NOT ≡ 1 mod 12');

   if BigInteger.Remainder(n-117,468)=0 then
      memo6.Lines.Add('N is ≡ 117 mod 468')
    else
      memo6.Lines.Add('N is NOT ≡ 117 mod 468');

   if BigInteger.Remainder(n-81,324)=0 then
      memo6.Lines.Add('N is ≡ 81 mod 324')
    else
      memo6.Lines.Add('N is NOT ≡ 81 mod 324');

   Sigma := BigInteger.Divide(BigInteger.Pow(q,alpha+1)-1,q-1);
   for j := 0 to numps-1 do
     Sigma := BigInteger.Multiply(Sigma,BigInteger.Divide(BigInteger.Pow(ps_array[j],2*es_array[j]+1)-1,ps_array[j]-1));

   BigInteger.DivMod(Sigma,n, divq, divr);
   if divq < 2 then
     memo6.Lines.Add('σ(n)/n < 2')
   else
   if (divq=2) and (divr=0) then
     memo6.Lines.Add('σ(n)/n = 2')
   else
     memo6.Lines.Add('σ(n)/n > ' + divq.ToString);

   memo6.Lines.Add('------------------------------------------------------------------');
  end;

begin
  setlength(ps_array, numps);
  setlength(es_array, numps);
  setlength(ps_index, numps);
  setlength(es_index, numps);

  q_index := 0;
  alpha_index := 0;

  for i := 0 to numps-1 do
  begin
    ps_index[i] := 0;
    es_index[i] := 0;
  end;

  while true do
  begin
    CheckNumber;
    for i := numps downto 0 do
    begin
      if i > 0 then
      begin
        es_index[i-1] := es_index[i-1] + 1;
        if stringgrid1.Cells[2*i+1,es_index[i-1]] <> '' then
          break;
        es_index[i-1] := 0;
        ps_index[i-1] := ps_index[i-1] + 1;
        if stringgrid1.Cells[2*i,ps_index[i-1]] <> '' then
          break;
        ps_index[i-1] := 0;
      end
      else
      begin
        alpha_index := alpha_index + 1;
        if stringgrid1.Cells[1,alpha_index] <> '' then
          break;
        alpha_index := 0;
        q_index := q_index + 1;
        if stringgrid1.Cells[0,q_index] = '' then
          exit;
      end;
    end;

  end;
end;